# "Cosmos DB for DBAs" - December 1, 2023

**Chris Joakim, Microsoft, Cosmos DB Global Back Belt (GBB)**

This Page: https://github.com/cjoakim/azure-cosmos-db/blob/main/presentations/20231201.md

---

## Agenda

```
- Overview of Cosmos DB
  - Multi-Modal
  - Deployments: Single-Region, Multi-Region, SLA, and HA/DR
  - Account Structure
  - Document Structure
  - Request Units, Throughput, Partitioning

- Discuss Relational vs NoSQL

- Briefly List Key Integrations
  - Ingestion, Search, Change Feed, Synapse Link ( we can cover these in future sessions)

- Design and Best Practices

- Anti-Patterns - how NOT to use Cosmos DB

- Logging and Reporting with Azure Monitor

- Identify Topics of Interest for the subsequent meetings, such as:
  - A discussion and demonstration of the Cosmos DB Change Feed
  - A discussion and demonstration of the Cosmos DB Synapse Link and HTAP
  - Deeper discussion of Logging, Reporting, Alerts
  - Azure Entra (i.e. - Azure Active Directory) integration
  - Graph use-cases with Cosmos DB
  - SQL deep-dive, Transactions, Concurrency Control
  - SDK deep-dive
  - Optimization deep-dive
```

---

## Overview of Cosmos DB

  - https://learn.microsoft.com/en-us/azure/cosmos-db/

  - **Why Cosmos DB?**
    - Cosmos DB is a fully managed **PaaS** service
    - **High-Performance, and Low-Latency**
      - Capable of millions of operations per second
      - Performance SLA 10ms point-reads
    - **High Availability**
      - 99.99% (single region), 99.999% (multi-region)
    - **Geo Replication**
      - Single Region deployment or Multiple Regions with fast replication
    - **Excellent Cloud-Native Integrations**
      - Ingest:  Azure Stream Analytics, Azure Data Factory, Spark Connector, Microsoft Fabric
      - Exhaust: Change Feed, Synapse Link (HTAP), Azure AI (Cognitive) Search, Azure Monitor
    - Disaster Recovery - system-managed failover, or manual failover
    - Excellent SDKs - C#, Java, Python, JavaScript
    - **Variable Pricing Model** - RU-based, with Autoscale - pay for what you use
    - Data is **Schemaless** - for agile and rapid application development

  - **It's a "Multi-Modal" database - you can create several kinds of Cosmos DB accounts**
    - We call these **APIs**
    - NoSQL
    - Mongo
    - Gremlin
    - Cassandra
    - Cassandra Managed Instance
    - Mongo vCore
    - We'll focus our discussion on the NoSQL API

  - **Deployments: Single-Region, Multi-Region, SLA, and HA/DR**
    - Single Region - 99.99% SLA
    - Single Region with AZ - 99.995% SLA
    - Multi-Region - 99.999% SLA
      - Multi-Region with Single write region
      - Multi-Region with Multiple write regions
        - Five consistency levels - Strong to Eventual

  - **Account Structure**
    - A Cosmos DB **account** has n-number of **databases**
    - A **database** has n-number of **containers**

  - **Access Cosmos DB using read-write or read-only Keys, or RBAC (AAD/Entra)**
    - Key-based access is at the database level

  - **Document Structure**
    - Each **container** requires a **partition-key attribute** (it's NOT a primary-key)
      = The name **pk** is commonly used as the partition-key attribute
      - Each **Document** is JSON
      - Each **document is entirely schemaless** other than the partition-key
      - You can provide an **id** value, or Cosmos DB will generate it
        - id value must be unique with the partition-key
        - id is typically a uuid/guid value

  - **Sample Document**
    - see the id and pk values
    - note the system-generated underscored attributes (_ts, _etag, etc)
    - note the arbritrary nested structure of the data
      - keywords is a list
      - dependencies is an object with keys and values
      - string, integer, and number values
      - A Valid JSON document is a Valid Cosmos DB document

```
    {
        "id": "3a939226-f136-4970-a111-a8b63faa8f6a",
        "pk": "express",
        "doctype": "library",
        "label": "express",
        "tenant": "123",
        "lob": "npm",
        "cacheKey": "library|express",
        "name": "express",
        "desc": "Fast, unopinionated, minimalist web framework",
        "keywords": [
            "express",
            "framework",
            "sinatra",
            "web",
            "rest",
            "restful",
            "router",
            "app",
            "api"
        ],
        "dependencies": {
            "vary": "~1.1.2",
            "methods": "~1.1.2",
            "escape-html": "~1.0.3",
            "finalhandler": "~1.1.2",
            "serve-static": "1.14.1",
            "parseurl": "~1.3.3",
            "path-to-regexp": "0.1.7",
            "content-disposition": "0.5.3",
            "content-type": "~1.0.4",
            "body-parser": "1.19.0",
            "depd": "~1.1.2",
            "utils-merge": "1.0.1",
            "qs": "6.7.0",
            "debug": "2.6.9",
            "cookie": "0.4.0",
            "accepts": "~1.3.7",
            "cookie-signature": "1.0.6",
            "on-finished": "~2.3.0",
            "statuses": "~1.5.0",
            "etag": "~1.8.1",
            "proxy-addr": "~2.0.5",
            "range-parser": "~1.2.1",
            "setprototypeof": "1.1.1",
            "type-is": "~1.6.18",
            "fresh": "0.5.2",
            "encodeurl": "~1.0.2",
            "merge-descriptors": "1.0.1",
            "send": "0.17.1",
            "array-flatten": "1.1.1",
            "safe-buffer": "5.1.2"
        },
        "devDependencies": {
            "marked": "0.6.2",
            "istanbul": "0.4.5",
            "pbkdf2-password": "1.2.1",
            "express-session": "1.16.1",
            "mocha": "5.2.0",
            "ejs": "2.6.1",
            "multiparty": "4.2.1",
            "cookie-parser": "~1.4.4",
            "eslint": "2.13.1",
            "vhost": "~3.0.2",
            "connect-redis": "3.4.1",
            "morgan": "1.9.1",
            "method-override": "3.0.0",
            "hbs": "4.0.4",
            "should": "13.2.3",
            "supertest": "3.3.0",
            "after": "0.8.2",
            "cookie-session": "1.3.3"
        },
        "author": "TJ Holowaychuk <tj@vision-media.ca>",
        "maintainers": [
            "dougwilson <doug@somethingdoug.com>",
            "jasnell <jasnell@gmail.com>",
            "mikeal <mikeal.rogers@gmail.com>"
        ],
        "version": "4.17.1",
        "homepage": "http://expressjs.com/",
        "library_age_days": 3166,
        "version_age_days": 96,
        "_etag": "\"0500a282-0000-0100-0000-63e1807a0000\"",
        "_rid": "gm8hALNuoCu8AwAAAAAAAA==",
        "_self": "dbs/gm8hAA==/colls/gm8hALNuoCs=/docs/gm8hALNuoCu8AwAAAAAAAA==/",
        "_attachments": "attachments/",
        "_ts": 1675722874
    }
```
    
  - **Request Units and Provisioned Throughput**
    - The **Request Unit (RU) is the unit of throughput and scale**
    - You can specify throughput at the Database Level or Container Level
      - Container Level - this is the typical case
      - Database Level - For 25 or fewer Containers
    - You can use **Manual Throughput** (per container) or **Autoscale Throughput**
    - Throughput is available 24x7
    - There is a minimum Throughput value, typically 400

  - You can also create a **Serverless Cosmos DB Account**
    - Has capacity and throughput limits
    - Pay per actual RU use
    - Can "scale-to-zero"
    - Best for Dev and Test environments

## Discuss Relational vs NoSQL Differences

- Nodes - Single vs Horizontal
- Schemas - fixed vs flexible, re: both structure and datatypes
- Transactions - Across tables vs In-Container In-Logical-Partition
- Joins - Locking vs OCC
- Data Duplication - 3NF vs Intentional Duplication in some cases
- ANSI SQL vs Cosmos DB SQL

## Briefly List Key Integrations

  - Ingestion
    - Azure Data Factory (ADF)
    - Azure Stream Analytics
    - Spark - Azure Synapse, Azure Databricks, Microsoft Fabric
    - SDK Clients - DotNet, Java, Python, JavaScript, etc
  - Outputs
    - Azure AI Search (formerly Cognitive Search)
    - Change Feed
    - Synapse Link and the HTAP pattern

We can cover these in future sessions.

## Partitioning - Physical and Logical


## Design and Best Practices

- Start with one container, add more as necessary
  - Don't start with a complex ERD diagram and try to port the design to Cosmos DB

- Choice of a Partition Key is Critical
  - It should be a value that you often/usually query on
  - Avoid **cross-partition** queries
  - The value should be **well-distributed with high-cardinality**


- https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/modeling-data

## Anti-Patterns - how NOT to use Cosmos DB

- Cosmos DB is not a **data lake**
- Cosmos DB is not a **data warehouse**
- Avoid repeated daily truncate-and-bulk-load scenarios
- Think differently - Don't try to use a Relational Entity-based design

## Logging and Reporting with Azure Monitor

- [Logging Presentation in this repo](https://github.com/cjoakim/azure-cosmos-db/tree/main/presentations/logging)

- [Throughput Control repo](https://github.com/cjoakim/azure-cosmos-db-throughput/tree/main/java)